<!DOCTYPE html>

<html lang="en">
<head>
<title>Ticino Data Experience</title>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0, shrink-to-fit=no">
<meta name="mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
<style>
body {
  width: 100%;
  height: 100%;
  background-color: #000;
  color: #fff;
  margin: 0px;
  padding: 0;
  overflow: hidden;
}
#clock {
  position: absolute;
  bottom: 1em;
  left: 1em;
  font: 12pt Arial,sans-serif;
}
</style>
</head>

<body>

<div id="clock"></div>

</body>

<script>
/*
 * Debug parameters.
 */
WebVRConfig = {
  /**
   * webvr-polyfill configuration
   */

  // Forces availability of VR mode.
  //FORCE_ENABLE_VR: true, // Default: false.
  // Complementary filter coefficient. 0 for accelerometer, 1 for gyro.
  //K_FILTER: 0.98, // Default: 0.98.
  // How far into the future to predict during fast motion.
  //PREDICTION_TIME_S: 0.040, // Default: 0.040 (in seconds).
  // Flag to disable touch panner. In case you have your own touch controls
  //TOUCH_PANNER_DISABLED: true, // Default: false.
  // Enable yaw panning only, disabling roll and pitch. This can be useful for
  // panoramas with nothing interesting above or below.
  //YAW_ONLY: true, // Default: false.
  // Enable the deprecated version of the API (navigator.getVRDevices).
  //ENABLE_DEPRECATED_API: true, // Default: false.
  // Scales the recommended buffer size reported by WebVR, which can improve
  // performance. Making this very small can lower the effective resolution of
  // your scene.
  BUFFER_SCALE: 0.5, // default: 1.0
  // Allow VRDisplay.submitFrame to change gl bindings, which is more
  // efficient if the application code will re-bind it's resources on the
  // next frame anyway.
  // Dirty bindings include: gl.FRAMEBUFFER_BINDING, gl.CURRENT_PROGRAM,
  // gl.ARRAY_BUFFER_BINDING, gl.ELEMENT_ARRAY_BUFFER_BINDING,
  // and gl.TEXTURE_BINDING_2D for texture unit 0
  // Warning: enabling this might lead to rendering issues.
  //DIRTY_SUBMIT_FRAME_BINDINGS: true // default: false
};
</script>

<!--
  A polyfill for Promises. Needed for IE and Edge.
  -->
<script src="build/es6-promise/dist/es6-promise.js"></script>

<!--
  three.js 3d library
  -->
<script src="build/three/three.js"></script>

<!--
  VRControls.js acquires positional information from connected VR devices and applies the transformations to a three.js camera object.
   -->
<script src="build/three/examples/js/controls/VRControls.js"></script>

<!--
  VREffect.js handles stereo camera setup and rendering.
  -->
<script src="build/three/examples/js/effects/VREffect.js"></script>

<script src="build/three/examples/js/loaders/OBJLoader.js"></script>

<!--
  A polyfill for WebVR using the Device{Motion,Orientation}Event API.
  -->
<script src="build/webvr-polyfill/build/webvr-polyfill.js"></script>

<!--
  Helps enter and exit VR mode, provides best practices while in VR.
  -->
<script src="build/webvr-manager.js"></script>

<script src="lib/d3.v3.min.js"></script>
<script src="lib/d3-threeD.js"></script>
<script src="lib/fit-projection.js"></script>
<script src="lib/features.js"></script>

<script>
// Setup three.js WebGL renderer. Note: Antialiasing is a big performance hit.
// Only enable it if you actually need to.
var renderer = new THREE.WebGLRenderer({antialias: true});
renderer.setPixelRatio(window.devicePixelRatio);

// Append the canvas element created by the renderer to document body element.
document.body.appendChild(renderer.domElement);

// Create a three.js scene.
var scene = new THREE.Scene();

// Create a three.js camera.
var camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 10000);

// Apply VR headset positional data to camera.
var controls = new THREE.VRControls(camera);
controls.standing = true;

// Apply VR stereo rendering to renderer.
var effect = new THREE.VREffect(renderer);
effect.setSize(window.innerWidth, window.innerHeight);


// Add a repeating grid as a skybox.
var boxSize = 30;
var loader = new THREE.TextureLoader();
loader.load('img/box.png', onTextureLoaded);

function onTextureLoaded(texture) {
  texture.wrapS = THREE.RepeatWrapping;
  texture.wrapT = THREE.RepeatWrapping;
  texture.repeat.set(boxSize, boxSize);

  var geometry = new THREE.BoxGeometry(boxSize, boxSize, boxSize);
  var material = new THREE.MeshBasicMaterial({
    map: texture,
    color: 0x01BE00,
    side: THREE.BackSide
  });

  // Align the skybox to the floor (which is at y=0).
  skybox = new THREE.Mesh(geometry, material);
  skybox.position.y = boxSize/2;
  scene.add(skybox);

  // Load data

  var manager = new THREE.LoadingManager();
	manager.onProgress = function ( item, loaded, total ) {

		console.log( item, loaded, total );

	};

	var texture = new THREE.Texture();

	var onProgress = function ( xhr ) {
		if ( xhr.lengthComputable ) {
			var percentComplete = xhr.loaded / xhr.total * 100;
			console.log( Math.round(percentComplete, 2) + '% downloaded' );
		}
	};

	var onError = function ( xhr ) {
	};

  scene.add( new THREE.HemisphereLight( 0x606060, 0x404040 ) );

	var light = new THREE.DirectionalLight( 0xffffff );
	light.position.set( 1, 1, 1 ).normalize();
	scene.add( light );

  // var loader = new THREE.OBJLoader( manager );
	// loader.load( 'waves-4.obj', function ( object ) {
  //
	// 	object.traverse( function ( child ) {
  //
	// 		if ( child instanceof THREE.Mesh ) {
  //
	// 			child.material =  new THREE.MeshBasicMaterial( {
  //         color: 0xffffff,
  //         opacity: 0.5,
  //         transparent: true
  //       });
  //
	// 		}
  //
	// 	} );
  //
  //   object.position.y =object.position.y + 0.1;
  //   object.position.x =object.position.x - 3;
  //   object.position.x =object.position.x - 3;
	// 	object.rotation.y =-object.rotation.y;
	// 	scene.add( object );
  //
	// }, onProgress, onError );

  // For high end VR devices like Vive and Oculus, take into account the stage
  // parameters provided.
  setupStage();
}

var groupMap, groupBoxes = [];

var dataPos = 0, dataLen = 0;
var oasidata, geodata;

d3.json("data/oasi_5year.json", function (error, oasi_5year) {
d3.json("data/swiss-cantons-ticino.json", function (error, map_ticino) {
loader.load('img/kgrs1000_ticino.jpg', function(texture) {

  geodata = map_ticino;

  oasidata = { traffic: [], temp: [], noise: [] };
  oasi_5year.traffic.Camignolo.locations[0].data.forEach(function(l) {
    oasidata.traffic.push({
      date: new Date(l.date), val: l.values[0].value
    });
  });
  oasi_5year.temperature.Lugano.locations[0].data.forEach(function(l) {
    oasidata.temp.push({
      date: new Date(l.date), val: l.values[0].value
    });
  });
  oasi_5year.noise_min["Camignolo Nord"].locations[0].data.forEach(function(l) {
    oasidata.noise.push({
      date: new Date(l.date), val: l.values[0].value
    });
  });
  dataLen = oasidata.traffic.length;

  texture.offset.x = 0.5;
  texture.offset.y = 0.5;

  var material = new THREE.MeshBasicMaterial({
    map: texture,
    color: 0xffffff,
    opacity: 0.3,
    transparent: true,
    shading: THREE.FlatShading,
    overdraw: true,
    side: THREE.BackSide
  });

  projectorGeom = fitProjection(d3.geo.mercator(), geodata, [[0.5,0.5],[-0.5,-0.5]], true);
  groupMap = renderFeatures(projectorGeom, geodata.features, scene, material, false);

  groupMap[0].rotation.x = Math.PI/2;
  groupMap[0].position.set(0, 0, 0);
  var upupup = 24;
  groupMap[0].scale.set(upupup, upupup, upupup/2);

  var geometry = new THREE.BoxGeometry( 0.1, 0.1, 0.1 );

  function shuffleGameObject(object, i) {
			object.Speed = Math.floor(Math.random()*7) + 1;
      object.Speed *= (Math.random()*2 >= 1) ? -1 : 1;
			object.Orientation = (Math.random()*2 >= 1);
			object.material.color.setHex( Math.random() * 0xffffff );
			object.position.z = -10 + Math.floor(Math.random()*20);
      object.position.x = -10 +i*0.2;
    }

  for ( var i = 0; i < 200; i ++ ) {

    var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( {
      color: Math.random() * 0xffffff,
      transparent: true,
      opacity: 1
    } ) );

    shuffleGameObject(object, i);
    groupBoxes.push(object);

    scene.add( object );
  }

});
});
});

function onDocumentMouseWheel( event ) {

    dataPos += (event.wheelDeltaY > 0) ? 1 : -1;
    if (dataPos < 0) dataPos = 0;
    if (dataPos > dataLen) dataPos = dataLen;

    // var dt = oasidata.traffic.Camignolo.locations[0].data.length;

}
window.addEventListener('mousewheel', onDocumentMouseWheel, false);

// Create a VR manager helper to enter and exit VR mode.
var params = {
  hideButton: false, // Default: false.
  isUndistorted: false // Default: false.
};
var manager = new WebVRManager(renderer, effect, params);



// Kick off animation loop
requestAnimationFrame(animate);

window.addEventListener('resize', onResize, true);
window.addEventListener('vrdisplaypresentchange', onResize, true);

// Request animation frame loop function
var lastRender = 0;
function animate(timestamp) {
  var delta = Math.min(timestamp - lastRender, 500);
  lastRender = timestamp;

  // Update VR headset position and apply to camera.
  controls.update();

  // Render the scene through the manager.
  manager.render(scene, camera, timestamp);

  var carBounds = 15;
  for (var i = 0; i < groupBoxes.length; i++) {
    var obj = groupBoxes[i];
    var px = obj.Orientation ? obj.position.x : obj.position.z;
  	var px = px + (obj.Speed * 0.02);
  	px = (px < -carBounds) ? carBounds : (px > carBounds) ? -carBounds : px;
    if (obj.Orientation) obj.position.x = px;
    if (!obj.Orientation) obj.position.z = px;
  }

  requestAnimationFrame(animate);
}

function onResize(e) {
  effect.setSize(window.innerWidth, window.innerHeight);
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
}

var display;

// Get the HMD, and if we're dealing with something that specifies
// stageParameters, rearrange the scene.
function setupStage() {
  navigator.getVRDisplays().then(function(displays) {
    if (displays.length > 0) {
      display = displays[0];
      if (display.stageParameters) {
        setStageDimensions(display.stageParameters);
      }
    }
  });
}

function setStageDimensions(stage) {
  // Make the skybox fit the stage.
  var material = skybox.material;
  scene.remove(skybox);

  // Size the skybox according to the size of the actual stage.
  var geometry = new THREE.BoxGeometry(stage.sizeX, boxSize, stage.sizeZ);
  skybox = new THREE.Mesh(geometry, material);

  // Place it on the floor.
  skybox.position.y = boxSize/2;
  scene.add(skybox);
}


</script>

</html>
